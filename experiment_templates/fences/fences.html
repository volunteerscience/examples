<script>

var cWidth = 300; // size of canvas
var cHeight = 300;

var xBoxes, yBoxes; // size of the grid

var pColor; // player colors
var score = new Array(); // player => int

var paper; // raphael
var boxes; // all the boxes
var lines; // all the lines
var gap = 3;
var lineWidth = 6;


var curPlayer = 1;
var scored = false;

function Box(id, x, y, r) {
  this.id = id;
  this.lines = new Array();
  this.owner = 0; // who won it

  this.circle = paper.circle(x,y,r);
  this.circle.attr("stroke-width",0);
  this.circle.toBack();
  
  // called when a player clicked a neighboring box
  var myBox = this;
  this.update = function(player) {
    for (var idx in myBox.lines) {
      var line = myBox.lines[idx];
      if (line.owner == 0) return;
    }
    myBox.owner = player;
    score[player]++;
    scored = true;
    myBox.circle.attr("fill",pColor[player]);
  }
}

function Line(id, boxA, boxB, x1, y1, x2, y2) {
  this.id = id;
  
  // so you can set either a or b, or both
  if (boxA == null) {
    boxA = boxB;
    boxB = null;
  }
  
  
  this.a = boxA;
  this.b = boxB;
  
  boxA.lines.push(this);
  
  if (boxB != null) {
    boxB.lines.push(this);
  }
  this.owner = 0; // who clicked it
  
  this.line = paper.path("M"+x1+","+y1+"L"+x2+","+y2);
  this.line.attr({'stroke': pColor[0], 'stroke-width': lineWidth});
  this.line.toFront();
  
  var myLine = this;
  this.click = function(player) {
    if (myLine.owner != 0) return;
    scored = false;   
    
    myLine.line.attr('stroke', pColor[player]);
    myLine.owner = player;
    myLine.a.update(player);
    if (myLine.b != null) {
      myLine.b.update(player);
    }

    // submit move  
    if (! scored) {  
      curPlayer++;
      if (curPlayer > 3) curPlayer = 1; 
    }
  }
  
  this.line.click(function() {
    myLine.click(curPlayer);
  });
}

function initialize() {
  pColor = new Array();
  pColor[0] = "#AAA";
  pColor[1] = "#F00";
  pColor[2] = "#00F";
  pColor[3] = "#0F0";
  
  initializeGame(10,10);
}

function initializeGame() {
  xBoxes = 8; //parseInt(variables['xBoxes']);
  yBoxes = 6; //parseInt(variables['yBoxes']);

  
  paper = Raphael("canvas", cWidth+lineWidth, cHeight+lineWidth);
  paper.clear();
  // paper.setViewBox(x, y, w, h, fit) // zoom/pan

  boxes = new Array();
  lines = new Array();
  
  initializeHexGrid();

  background = paper.rect(-10, -10, cWidth+20, cHeight+20, 10).attr({fill: "#FFA", stroke: "none"});  
  background.toBack();
}

function initializeSquareGrid() {
  paper.setViewBox(-lineWidth/2, -lineWidth/2, cWidth+lineWidth, cWidth+lineWidth, false);

  var boxWidth = cWidth/xBoxes;
  var boxHeight = cHeight/yBoxes;

  for (var y = 0; y <= yBoxes; y++) {
    for (var x = 0; x <= xBoxes; x++) {
      // add the box
      var newBox = null;
      if (x < xBoxes && y < yBoxes) {
        newBox = new Box(boxes.length, x*boxWidth+boxWidth/2, y*boxHeight+boxHeight/2,boxWidth/4);
        boxes.push(newBox);
      }
      
      // horizontal line
      if (x < xBoxes) {
        var a = newBox; // the box below the line
        var b = null;
        if (y > 0) {
          b = boxes[x + (y-1)*xBoxes]; // the box above the line
        }
        lines.push( new Line(lines.length, a, b, x*boxWidth+gap, y*boxWidth,  (x+1)*boxWidth-gap, y*boxWidth) );
      }
      
      // vertical line
      if (y < yBoxes) {
        var a = newBox; // the box to the right of the line
        var b = null;
        if (x > 0) {
          b = boxes[x-1 + y*xBoxes];
        }
        lines.push( new Line(lines.length, a, b, x*boxWidth, y*boxWidth+gap, x*boxWidth, (y+1)*boxWidth-gap) );
      }
    }
  }
}

function initializeHexGrid() {
  paper.setViewBox(-lineWidth, -lineWidth, cWidth+lineWidth, cWidth+lineWidth, false);

  var r3 = Math.sqrt(3)/2.0;
  var boxWidth = cWidth/(xBoxes*1.6);
  var dy = boxWidth*r3;
  
//  alert(boxWidth+" "+dy);
  
  for (var y = 0; y < (yBoxes+1)*2; y++) {
    for (var x = 0; x <= xBoxes*1.5; x++) {
      var xOff = 0;
      if (y % 2 == 0) {
        xOff = 0.5;
      }
      
      if ((x+(y%2)) % 3 == 0) {
        var idx = Math.floor(((y/2)-1)*xBoxes + x/3); // index of box 1 row above
      
      
        var newBox = null;

        // top horizontal line
        if (x < xBoxes*1.5) { // this is false on the right edge       
          if (y < yBoxes*2) { // no boxes under the bottom lines
            newBox = new Box(boxes.length, (xOff+x+0.5)*boxWidth, (y+1)*dy, boxWidth/2);
            boxes.push(newBox);
          }
                    
          
          var a = newBox; // below
          var b = null;
          if (y > 1) { // not top rows
            b = boxes[idx]; // 1 row above
          }

          lines.push( new Line(lines.length, a, b, (x+xOff)*boxWidth+gap,y*dy, (x+xOff+1)*boxWidth-gap, y*dy) );
        }
         
        // diagional / behind x 
        if (y < yBoxes*2+1 &&  // right edge
           (y > 0 || x < xBoxes*1.5) && // upper right corner
           (y < yBoxes*2 || x > 0) // lower left corner
           ) {
          
          
          var a = newBox; // lower right
          var b = null;
          if (y > 0 && x > 0) { // not top row nor first column
            b = boxes[idx+xBoxes/2 +(y%2)-1]; // upper left
          }

          lines.push( new Line(lines.length, a, b, (x+xOff-0.5)*boxWidth+gap/2, (y+1)*dy-gap*r3, (x+xOff)*boxWidth-gap/2, y*dy+gap*r3) );
        }

        // delme
        if (newBox == null) {
          newBox = boxes[0];
        }

        // diagional \ before x 
        if (y > 0) {
          var a = null;
          if (x < xBoxes*1.5) { // right side
            a = boxes[idx]; // upper right
          }
            
          var b = null;
          if (x > 0) { // left side
            b = boxes[idx+xBoxes/2 +(y%2)-1]; // lower left
          }
          
          lines.push( new Line(lines.length, a, b, (x+xOff-0.5)*boxWidth+gap/2, (y-1)*dy+gap*r3, (x+xOff)*boxWidth-gap/2, y*dy-gap*r3) );
        }
      }
    }
  }
}


</script>

<h1>Welcome to Fences</h1>

<div id="canvas"></div>
